WEBVTT

1
00:00:00.220 --> 00:00:01.128
现在 你已经学会了在Octave中

2
00:00:01.128 --> 00:00:03.062
如何加载或存储数据

3
00:00:03.062 --> 00:00:04.743
如何把数据存入矩阵 等等

4
00:00:04.743 --> 00:00:06.301
在这段视频中

5
00:00:06.301 --> 00:00:08.252
我将向你介绍

6
00:00:08.252 --> 00:00:10.343
如何对数据进行运算

7
00:00:10.343 --> 00:00:12.296
稍后我们将使用这些

8
00:00:12.320 --> 00:00:16.860
运算操作来实现我们的学习算法

9
00:00:16.860 --> 00:00:19.360
现在我们开始吧

10
00:00:19.610 --> 00:00:21.031
这是我的 Octave 窗口

11
00:00:21.031 --> 00:00:22.737
我现在快速地

12
00:00:22.737 --> 00:00:24.939
初始化一些变量

13
00:00:24.940 --> 00:00:26.679
比如设置A

14
00:00:26.679 --> 00:00:29.185
为一个3×2的矩阵

15
00:00:29.820 --> 00:00:31.495
设置B为

16
00:00:31.510 --> 00:00:33.319
一个3 × 2矩阵

17
00:00:33.330 --> 00:00:35.106
设置C为

18
00:00:35.120 --> 00:00:38.419
2 × 2矩阵

19
00:00:39.150 --> 00:00:41.948
现在 我想算两个矩阵的乘积

20
00:00:41.960 --> 00:00:44.121
比如说 A × C

21
00:00:44.121 --> 00:00:45.713
我只需键入A×C

22
00:00:45.740 --> 00:00:48.848
这是一个 3×2 矩阵乘以 2×2 矩阵

23
00:00:48.860 --> 00:00:52.135
得到这样一个3×2矩阵

24
00:00:52.160 --> 00:00:53.736
你也可以对每一个元素

25
00:00:53.740 --> 00:00:56.472
做运算 方法是做点乘运算A .*B

26
00:00:56.500 --> 00:00:57.615
这么做

27
00:00:57.615 --> 00:00:59.138
Octave将矩阵 A 中的每一个元素

28
00:00:59.138 --> 00:01:00.584
与矩阵 B 中的

29
00:01:00.590 --> 00:01:02.558
对应元素相乘

30
00:01:02.560 --> 00:01:06.390
这是A 这是B 这是A .* B

31
00:01:06.700 --> 00:01:09.412
比如说 这里第一个元素

32
00:01:09.420 --> 00:01:10.940
1乘以11得到11

33
00:01:10.950 --> 00:01:14.045
第二个元素是

34
00:01:14.045 --> 00:01:16.752
2乘以12得到24

35
00:01:16.760 --> 00:01:18.196
这就是两个矩阵的

36
00:01:18.196 --> 00:01:19.673
元素位运算

37
00:01:19.673 --> 00:01:21.500
通常来说

38
00:01:21.520 --> 00:01:23.359
在Octave中

39
00:01:23.380 --> 00:01:25.132
点号一般

40
00:01:25.132 --> 00:01:27.435
用来表示元素位运算

41
00:01:27.435 --> 00:01:28.882
这里是一个矩阵A

42
00:01:28.882 --> 00:01:31.735
这里我输入A .^ 2

43
00:01:31.735 --> 00:01:33.001
这将对矩阵A中

44
00:01:33.010 --> 00:01:35.671
每一个元素平方

45
00:01:35.690 --> 00:01:37.411
所以 1的平方是1

46
00:01:37.411 --> 00:01:40.813
2的平方是4 等等

47
00:01:40.870 --> 00:01:42.215
我们设V是一个向量

48
00:01:42.260 --> 00:01:46.085
设V为 [1; 2; 3] 是列向量

49
00:01:46.180 --> 00:01:47.848
你也可以输入

50
00:01:47.860 --> 00:01:49.675
1 ./ V

51
00:01:49.675 --> 00:01:51.533
得到每一个元素的倒数

52
00:01:51.533 --> 00:01:53.176
所以这样一来

53
00:01:53.210 --> 00:01:55.600
就会分别算出 1/1  1/2  1/3

54
00:01:55.600 --> 00:01:56.898
矩阵也可以这样操作

55
00:01:56.898 --> 00:01:58.436
1 ./ A 得到

56
00:01:58.470 --> 00:02:00.464
A中每一个元素的倒数

57
00:02:00.520 --> 00:02:03.342
同样地

58
00:02:03.342 --> 00:02:04.813
这里的点号

59
00:02:04.830 --> 00:02:08.193
还是表示对每一个元素进行操作

60
00:02:08.193 --> 00:02:09.663
我们还可以进行求对数运算

61
00:02:09.663 --> 00:02:11.591
也就是对每个元素

62
00:02:11.600 --> 00:02:14.257
进行求对数运算

63
00:02:14.257 --> 00:02:15.418
还有自然数e的幂次运算

64
00:02:15.420 --> 00:02:17.394
就是以e为底

65
00:02:17.394 --> 00:02:20.288
以这些元素为幂的运算

66
00:02:20.330 --> 00:02:21.432
所以这是e 这是e的平方

67
00:02:21.432 --> 00:02:23.105
这是e的立方

68
00:02:23.105 --> 00:02:26.010
v 矩阵是这样的

69
00:02:26.120 --> 00:02:28.187
我还可以用 abs

70
00:02:28.230 --> 00:02:30.172
来对 v 的每一个元素

71
00:02:30.172 --> 00:02:32.056
求绝对值

72
00:02:32.056 --> 00:02:34.418
当然这里 v 都是正数

73
00:02:34.430 --> 00:02:36.503
我们换成另一个

74
00:02:36.503 --> 00:02:38.543
这样对每个元素求绝对值

75
00:02:38.543 --> 00:02:40.428
得到的结果就是

76
00:02:40.430 --> 00:02:43.929
这些非负的元素

77
00:02:43.929 --> 00:02:45.465
还有 -v

78
00:02:45.465 --> 00:02:46.715
给出V中每个元素的相反数

79
00:02:46.730 --> 00:02:49.085
这等价于 -1 乘以 v

80
00:02:49.085 --> 00:02:50.653
不过一般就直接用 -v 就好了

81
00:02:50.653 --> 00:02:55.340
其实就等于 -1*v

82
00:02:55.990 --> 00:02:57.185
还有什么呢？

83
00:02:57.185 --> 00:02:58.343
还有一个技巧

84
00:02:58.343 --> 00:03:01.424
比如说 我们想对v中的每个元素都加1

85
00:03:01.424 --> 00:03:02.520
那么我们可以这么做

86
00:03:02.520 --> 00:03:05.407
首先构造一个

87
00:03:05.420 --> 00:03:09.010
3行1列的1向量

88
00:03:09.660 --> 00:03:12.666
然后把这个1向量跟原来的向量相加

89
00:03:12.666 --> 00:03:15.373
因此 v 向量从[1 2 3] 增至 [2 3 4]

90
00:03:15.373 --> 00:03:16.804
我用了一个

91
00:03:16.804 --> 00:03:21.439
length(v) 命令

92
00:03:21.890 --> 00:03:23.790
因此这样一来

93
00:03:23.790 --> 00:03:25.792
ones(length(v) ,1) 就相当于

94
00:03:25.820 --> 00:03:27.055
ones(3,1)

95
00:03:27.055 --> 00:03:29.525
所以这是ones(3,1)

96
00:03:29.580 --> 00:03:31.150
对吧 然后我做的是

97
00:03:31.230 --> 00:03:33.198
v + ones(3,1) 

98
00:03:33.198 --> 00:03:35.139
也就是将 v 的各元素

99
00:03:35.150 --> 00:03:36.605
都加上这些1

100
00:03:36.610 --> 00:03:38.112
这样就将 v 的每个元素

101
00:03:38.112 --> 00:03:40.340
增加了1

102
00:03:40.340 --> 00:03:41.984
另一种更简单的方法是

103
00:03:41.984 --> 00:03:44.472
直接用 v+1

104
00:03:44.472 --> 00:03:45.600
所以这是 v

105
00:03:45.650 --> 00:03:46.989
v + 1 也就等于

106
00:03:47.000 --> 00:03:49.257
把 v 中的每一个元素

107
00:03:49.280 --> 00:03:52.458
都加上1

108
00:03:52.458 --> 00:03:55.422
现在 让我们来谈谈更多的操作

109
00:03:55.450 --> 00:03:58.848
这是我的矩阵A 如果你想要求它的转置

110
00:03:58.848 --> 00:04:00.841
那么方法是用A‘

111
00:04:00.900 --> 00:04:02.653
这是单引号符号

112
00:04:02.660 --> 00:04:03.770
并且是左引号

113
00:04:03.770 --> 00:04:05.355
可能你的键盘上

114
00:04:05.355 --> 00:04:06.975
有一个左引号

115
00:04:06.975 --> 00:04:08.106
和一个右引号

116
00:04:08.106 --> 00:04:09.901
这里用的是左引号

117
00:04:09.950 --> 00:04:12.304
也就是标准的引号

118
00:04:12.304 --> 00:04:14.765
因此 A’

119
00:04:14.765 --> 00:04:16.172
将得出 A 的转置矩阵

120
00:04:16.172 --> 00:04:17.228
当然

121
00:04:17.228 --> 00:04:18.919
如果我写 (A‘)’

122
00:04:18.919 --> 00:04:20.405
也就是 A 转置两次

123
00:04:20.405 --> 00:04:21.650
那么我又重新得到矩阵 A

124
00:04:21.650 --> 00:04:26.509
还有一些有用的函数

125
00:04:26.540 --> 00:04:28.646
假如说 小写a

126
00:04:28.646 --> 00:04:30.546
是[1 15 2 0.5]

127
00:04:30.546 --> 00:04:34.266
这是一个1行4列矩阵

128
00:04:34.266 --> 00:04:36.239
假如说 val=max(a)

129
00:04:36.239 --> 00:04:37.833
这将返回

130
00:04:37.833 --> 00:04:39.328
A矩阵中的最大值

131
00:04:39.328 --> 00:04:41.481
在这里是15

132
00:04:41.500 --> 00:04:44.465
我还可以写 [val, ind] = max(a)

133
00:04:44.490 --> 00:04:47.115
这将返回

134
00:04:47.120 --> 00:04:49.634
a矩阵中的最大值

135
00:04:49.634 --> 00:04:51.289
存入val

136
00:04:51.289 --> 00:04:52.943
以及该值对应的索引

137
00:04:52.943 --> 00:04:56.028
 因此元素15对应的索引值为2 存入ind

138
00:04:56.028 --> 00:04:58.766
所以 ind 等于2

139
00:04:58.766 --> 00:05:00.148
特别注意一下

140
00:05:00.148 --> 00:05:03.155
如果你用命令 max(A) A是一个矩阵的话

141
00:05:03.180 --> 00:05:04.746
这样做就是对每一列

142
00:05:04.780 --> 00:05:07.848
求最大值

143
00:05:07.860 --> 00:05:11.525
等下再仔细讲讲

144
00:05:11.570 --> 00:05:13.305
我们还是用这个例子

145
00:05:13.305 --> 00:05:17.008
这个 小a 矩阵

146
00:05:17.040 --> 00:05:19.548
如果输入 a<3

147
00:05:19.590 --> 00:05:21.063
这将进行逐元素的运算

148
00:05:21.063 --> 00:05:22.624
所以 第一个元素

149
00:05:22.624 --> 00:05:24.855
是小于3的 因此返回1

150
00:05:24.855 --> 00:05:26.315
a的第二个元素

151
00:05:26.315 --> 00:05:27.435
不小于3 所以

152
00:05:27.435 --> 00:05:29.948
这个值是0 表示"非"

153
00:05:29.950 --> 00:05:31.258
第三个和第四个数字

154
00:05:31.300 --> 00:05:32.866
仍然是小于3

155
00:05:32.870 --> 00:05:35.667
2和0.5都小于3

156
00:05:35.667 --> 00:05:36.826
因此 这返回[1 1 0 1]

157
00:05:36.826 --> 00:05:38.441
也就是说

158
00:05:38.460 --> 00:05:40.241
对a矩阵的每一个元素

159
00:05:40.280 --> 00:05:42.504
与3进行比较

160
00:05:42.520 --> 00:05:44.008
然后根据每一个元素与3的大小关系

161
00:05:44.020 --> 00:05:47.382
返回1和0表示真与假

162
00:05:47.400 --> 00:05:48.843
现在 如果我写 find(a<3)

163
00:05:48.880 --> 00:05:50.708
这将告诉我

164
00:05:50.710 --> 00:05:52.149
a 中的哪些元素

165
00:05:52.190 --> 00:05:53.805
是小于3的

166
00:05:53.860 --> 00:05:55.202
是小于3的

167
00:05:55.202 --> 00:05:56.964
在这里就是第一 第三和第四个元素

168
00:05:56.964 --> 00:06:00.244
是小于3的

169
00:06:00.244 --> 00:06:01.465
下一个例子

170
00:06:01.465 --> 00:06:03.335
设A = magic(3)

171
00:06:03.340 --> 00:06:05.765
magic 函数返回什么呢

172
00:06:05.765 --> 00:06:07.409
让我们查看 magic 函数的帮助文件

173
00:06:09.390 --> 00:06:12.581
magic 函数将返回

174
00:06:12.581 --> 00:06:15.362
一个矩阵 称为魔方阵或幻方 (magic squares)

175
00:06:15.362 --> 00:06:17.722
它们具有以下

176
00:06:17.740 --> 00:06:20.012
这样的数学性质

177
00:06:20.030 --> 00:06:21.590
它们所有的行和列和对角线

178
00:06:21.590 --> 00:06:23.730
加起来都等于相同的值

179
00:06:23.730 --> 00:06:25.535
当然据我所知

180
00:06:25.580 --> 00:06:27.378
这在机器学习里

181
00:06:27.378 --> 00:06:28.385
基本用不上

182
00:06:28.385 --> 00:06:29.688
但我可以用这个方法

183
00:06:29.688 --> 00:06:31.720
很方便地生成一个

184
00:06:31.720 --> 00:06:33.058
3行3列的矩阵

185
00:06:33.058 --> 00:06:36.206
而这个魔方矩阵这神奇的方形屏幕。

186
00:06:36.220 --> 00:06:37.228
每一行 每一列

187
00:06:37.228 --> 00:06:39.500
每一个对角线

188
00:06:39.510 --> 00:06:41.055
三个数字加起来

189
00:06:41.055 --> 00:06:44.487
都是等于同一个数

190
00:06:44.510 --> 00:06:45.789
我只有在演示功能

191
00:06:45.800 --> 00:06:47.110
或者上课教 Octave 的时候

192
00:06:47.110 --> 00:06:48.118
会用到这个矩阵

193
00:06:48.140 --> 00:06:49.571
在其他有用的机器学习应用中

194
00:06:49.580 --> 00:06:51.103
这个矩阵其实没多大作用

195
00:06:51.103 --> 00:06:53.846
让我来看看别的

196
00:06:53.860 --> 00:06:59.356
如果我输入 [r,c] = find( A>=7 )

197
00:06:59.390 --> 00:07:02.657
这将找出所有A矩阵中

198
00:07:02.657 --> 00:07:03.797
大于等于7的元素

199
00:07:03.797 --> 00:07:05.246
因此

200
00:07:05.246 --> 00:07:07.044
r 和 c 分别表示行和列

201
00:07:07.100 --> 00:07:09.392
这就表示 第一行第一列的元素大于等于7

202
00:07:09.400 --> 00:07:10.973
第三行第二列的元素大于等于7

203
00:07:10.980 --> 00:07:13.178
第二行第三列的元素大于等于7

204
00:07:13.200 --> 00:07:14.788
我们来看看 第二行第三列的元素

205
00:07:14.800 --> 00:07:18.803
就是 A(2,3)

206
00:07:18.850 --> 00:07:21.102
是等于7的

207
00:07:21.120 --> 00:07:24.248
就是这个元素 确实是大于等于7的

208
00:07:24.248 --> 00:07:26.005
顺便说一句 其实我从来都

209
00:07:26.030 --> 00:07:27.613
不去刻意记住这个 find 函数

210
00:07:27.613 --> 00:07:28.944
到底是怎么用的

211
00:07:28.960 --> 00:07:30.323
我只需要会用 help 函数就可以了

212
00:07:30.323 --> 00:07:31.399
每当我在使用这个函数

213
00:07:31.399 --> 00:07:33.042
忘记怎么用的时候

214
00:07:33.070 --> 00:07:34.791
我就可以用 help 函数

215
00:07:34.791 --> 00:07:37.952
键入 help find 来找到帮助文档

216
00:07:37.970 --> 00:07:40.042
好吧 最后再讲两个内容

217
00:07:40.042 --> 00:07:41.549
一个是求和函数

218
00:07:41.549 --> 00:07:43.452
这是 a 矩阵

219
00:07:43.452 --> 00:07:44.755
键入 sum(a)

220
00:07:44.800 --> 00:07:46.500
就把 a 中所有元素加起来了

221
00:07:46.510 --> 00:07:47.660
如果我想把它们都乘起来

222
00:07:47.660 --> 00:07:49.404
键入 prod(a)

223
00:07:49.410 --> 00:07:50.795
prod 意思是 product(乘积)

224
00:07:50.800 --> 00:07:53.022
它将返回

225
00:07:53.022 --> 00:07:55.773
这四个元素的乘积

226
00:07:56.040 --> 00:07:58.215
floor(a) 是向下四舍五入

227
00:07:58.215 --> 00:07:59.465
因此对于 a 中的元素

228
00:07:59.470 --> 00:08:01.766
0.5将被下舍入变成0

229
00:08:01.766 --> 00:08:03.352
还有 ceil(A)

230
00:08:03.380 --> 00:08:04.815
表示向上四舍五入

231
00:08:04.815 --> 00:08:06.212
所以0.5将上舍入变为

232
00:08:06.220 --> 00:08:10.735
最接近的整数 也就是1

233
00:08:10.735 --> 00:08:12.143
还有

234
00:08:12.143 --> 00:08:13.322
我们来看

235
00:08:13.322 --> 00:08:14.418
键入 type(3)

236
00:08:14.418 --> 00:08:16.643
这通常得到一个3×3的矩阵

237
00:08:16.680 --> 00:08:20.444
如果键入 max(rand(3), rand(3))

238
00:08:20.460 --> 00:08:21.848
这样做的结果是

239
00:08:21.848 --> 00:08:24.963
返回两个3×3的随机矩阵

240
00:08:24.963 --> 00:08:26.897
并且逐元素比较 取最大值

241
00:08:26.900 --> 00:08:28.017
所以 你会发现所有这些

242
00:08:28.017 --> 00:08:29.063
数字几乎都比较大

243
00:08:29.063 --> 00:08:30.948
因为这里的每个元素

244
00:08:30.948 --> 00:08:32.581
都实际上是

245
00:08:32.581 --> 00:08:35.093
两个随机生成的矩阵

246
00:08:35.110 --> 00:08:38.269
逐元素进行比较 取最大的那个值

247
00:08:38.269 --> 00:08:40.316
这是刚才生成的

248
00:08:40.316 --> 00:08:43.258
3×3魔方阵 A

249
00:08:43.258 --> 00:08:47.704
假如我输入

250
00:08:47.730 --> 00:08:49.955
max(A,[],1)

251
00:08:49.955 --> 00:08:51.344
这样做会得到

252
00:08:51.360 --> 00:08:53.584
每一列的最大值

253
00:08:53.600 --> 00:08:54.892
所以第一例的最大值

254
00:08:54.910 --> 00:08:56.517
就是8

255
00:08:56.517 --> 00:08:58.335
第二列是9

256
00:08:58.335 --> 00:09:00.695
第三列的最大值是7

257
00:09:00.695 --> 00:09:02.064
这里的1表示

258
00:09:02.100 --> 00:09:03.665
取A矩阵第一个维度的最大值

259
00:09:03.700 --> 00:09:05.860
相对地

260
00:09:05.940 --> 00:09:07.874
如果我键入

261
00:09:07.910 --> 00:09:10.033
max(A,[],2)

262
00:09:10.033 --> 00:09:12.433
这将得到每一行的最大值

263
00:09:12.460 --> 00:09:13.449
所以 第一行的最大值

264
00:09:13.449 --> 00:09:14.525
是等于8

265
00:09:14.560 --> 00:09:16.561
第二行最大值是7

266
00:09:16.580 --> 00:09:18.105
第三行是9

267
00:09:18.105 --> 00:09:21.605
所以你可以用这个方法

268
00:09:21.605 --> 00:09:24.771
来求得每一行或每一列的最值

269
00:09:24.780 --> 00:09:26.988
另外

270
00:09:26.988 --> 00:09:29.019
你要知道 默认情况下

271
00:09:29.020 --> 00:09:30.091
max(A)返回的是

272
00:09:30.091 --> 00:09:31.628
每一列的最大值

273
00:09:31.630 --> 00:09:33.395
如果你想要

274
00:09:33.395 --> 00:09:35.040
找出整个矩阵A的最大值

275
00:09:35.040 --> 00:09:36.985
你可以输入

276
00:09:36.985 --> 00:09:39.558
max(max(A)) 像这样

277
00:09:39.558 --> 00:09:40.640
或者你可以将 A 矩阵转成

278
00:09:40.670 --> 00:09:42.507
一个向量

279
00:09:42.507 --> 00:09:44.739
然后键入 max(A(:))

280
00:09:44.750 --> 00:09:46.912
这样做就是把 A 当做一个向量

281
00:09:46.912 --> 00:09:51.539
并返回 A 向量中的最大值

282
00:09:51.572 --> 00:09:54.288
最后 让我们把 A 设为一个

283
00:09:54.288 --> 00:09:56.234
9行9列的魔方阵

284
00:09:56.234 --> 00:09:57.853
别忘了

285
00:09:57.853 --> 00:09:59.969
魔方阵具有的特性是

286
00:09:59.969 --> 00:10:03.535
每行每列和对角线的求和都是相等的

287
00:10:03.535 --> 00:10:06.209
这是一个9×9的魔方阵

288
00:10:06.240 --> 00:10:07.715
我们来求一个 sum(A,1)

289
00:10:07.715 --> 00:10:10.169
这样就得到每一列的总和

290
00:10:10.190 --> 00:10:11.104
所以这样做就是

291
00:10:11.104 --> 00:10:12.194
把 A 的每一列进行求和

292
00:10:12.194 --> 00:10:13.698
从这里我们也可以看出

293
00:10:13.700 --> 00:10:15.365
这也验证了 

294
00:10:15.365 --> 00:10:16.935
一个9×9的魔方阵

295
00:10:16.935 --> 00:10:20.124
确实每一列加起来都相等 都为369

296
00:10:20.124 --> 00:10:22.020
现在我们来求每一行的和

297
00:10:22.020 --> 00:10:24.643
键入sum(A,2)

298
00:10:24.643 --> 00:10:27.967
这样就得到了 

299
00:10:28.030 --> 00:10:29.269
A 中每一行的和

300
00:10:29.269 --> 00:10:30.522
A 中每一行的和

301
00:10:30.522 --> 00:10:32.113
加起来还是369

302
00:10:32.113 --> 00:10:34.485
现在我们来算

303
00:10:34.500 --> 00:10:35.934
A 的对角线元素的和

304
00:10:35.990 --> 00:10:37.362
看看它们的和

305
00:10:37.370 --> 00:10:39.696
是不是也相等

306
00:10:39.730 --> 00:10:40.924
我们现在构造一个

307
00:10:40.924 --> 00:10:42.613
9×9 的单位矩阵

308
00:10:42.613 --> 00:10:44.325
键入 eye(9)

309
00:10:44.360 --> 00:10:46.018
设为I9

310
00:10:46.018 --> 00:10:49.326
然后我们要用 A

311
00:10:49.326 --> 00:10:51.272
逐点乘以这个单位矩阵

312
00:10:51.300 --> 00:10:52.812
这是矩阵A

313
00:10:52.812 --> 00:10:56.350
我现在用 A 逐点乘以 eye(9)

314
00:10:56.490 --> 00:10:58.018
这样做的结果是

315
00:10:58.020 --> 00:11:00.035
两个矩阵对应元素

316
00:11:00.035 --> 00:11:01.150
将进行相乘

317
00:11:01.150 --> 00:11:03.605
除了对角线元素外

318
00:11:03.680 --> 00:11:06.421
其他元素都会得到0

319
00:11:06.421 --> 00:11:08.761
然后我对刚才求到的结果

320
00:11:08.780 --> 00:11:11.179
键入sum(sum(A.*eye(9))

321
00:11:11.180 --> 00:11:14.512
这实际上是求得了

322
00:11:14.512 --> 00:11:16.684
这个矩阵对角线元素的和 确实是369

323
00:11:16.684 --> 00:11:20.218
你也可以求另一条对角线的和

324
00:11:20.240 --> 00:11:22.385
这个是从左上角到右下角的

325
00:11:22.400 --> 00:11:24.158
你也可以求另一条对角线

326
00:11:24.180 --> 00:11:26.832
从左下角到右上角

327
00:11:26.832 --> 00:11:30.199
这个和  这个命令会有点麻烦

328
00:11:30.200 --> 00:11:31.535
其实你不需要知道这个

329
00:11:31.540 --> 00:11:33.122
我只是想给你看

330
00:11:33.122 --> 00:11:34.779
如果你感兴趣的话可以听听

331
00:11:34.779 --> 00:11:37.543
让我们来看看

332
00:11:37.600 --> 00:11:41.235
flipup/flipud 表示向上/向下翻转

333
00:11:41.235 --> 00:11:42.622
如果你用这个命令的话

334
00:11:42.622 --> 00:11:44.376
计算的就是副对角线上

335
00:11:44.376 --> 00:11:46.055
所有元素的和

336
00:11:46.055 --> 00:11:49.387
还是会得到369

337
00:11:49.390 --> 00:11:51.116
我来给你演示一下

338
00:11:51.120 --> 00:11:53.055
eye(9) 矩阵是这样

339
00:11:53.070 --> 00:11:57.300
那么 flipup(eye(9))

340
00:11:57.370 --> 00:11:58.986
将得到一个单位矩阵

341
00:11:58.986 --> 00:12:00.832
并且将它翻转

342
00:12:00.832 --> 00:12:01.822
不好意思打错了

343
00:12:01.822 --> 00:12:04.394
应该是flipud

344
00:12:04.400 --> 00:12:08.742
翻转以后所有的1就变成副对角线了

345
00:12:08.770 --> 00:12:10.430
最后再说一个命令

346
00:12:10.490 --> 00:12:12.706
然后就下课

347
00:12:12.760 --> 00:12:13.730
假如 A 是一个

348
00:12:13.730 --> 00:12:16.112
3×3的魔方阵

349
00:12:16.112 --> 00:12:17.221
同样地 如果你想

350
00:12:17.221 --> 00:12:18.493
这个矩阵的逆矩阵

351
00:12:18.493 --> 00:12:20.668
键入 pinv(A)

352
00:12:20.668 --> 00:12:23.612
通常称为伪逆矩阵 但这个名字不重要

353
00:12:23.612 --> 00:12:24.991
你就把它看成是

354
00:12:24.991 --> 00:12:26.927
矩阵 A 求逆

355
00:12:26.960 --> 00:12:28.313
因此这就是 A 矩阵的逆矩阵

356
00:12:28.313 --> 00:12:31.721
设 temp = pinv(A)

357
00:12:31.740 --> 00:12:33.596
然后再用temp 乘以 A

358
00:12:33.596 --> 00:12:35.362
这实际上得到的就是

359
00:12:35.362 --> 00:12:37.252
单位矩阵

360
00:12:37.260 --> 00:12:38.753
对角线为1 其他元素为0

361
00:12:38.753 --> 00:12:43.322
稍微圆整一下就是

362
00:12:44.120 --> 00:12:45.746
好了 这样我们就介绍了

363
00:12:45.750 --> 00:12:48.430
如何对矩阵中的数字

364
00:12:48.430 --> 00:12:50.865
进行各种操作

365
00:12:50.890 --> 00:12:53.055
在运行完某个

366
00:12:53.055 --> 00:12:54.350
学习算法之后

367
00:12:54.380 --> 00:12:55.876
通常一件最有用的事情

368
00:12:55.900 --> 00:12:57.223
是看看你的结果

369
00:12:57.230 --> 00:13:00.013
或者说让你的结果可视化

370
00:13:00.020 --> 00:13:01.675
在接下来的视频中

371
00:13:01.675 --> 00:13:03.233
我会非常迅速地告诉你

372
00:13:03.233 --> 00:13:04.230
如何很快地画出

373
00:13:04.300 --> 00:13:06.261
如何只用一两行代码

374
00:13:06.270 --> 00:13:07.814
你就可以快速地可视化你的数据

375
00:13:07.850 --> 00:13:09.901
画出你的数据

376
00:13:09.901 --> 00:13:11.101
这样你就能更好地理解

377
00:13:11.101 --> 00:13:14.880
你使用的学习算法 【教育无边界字幕组】翻译：Eroica_CMCS 校对：所罗门捷列夫 审核：Naplessss