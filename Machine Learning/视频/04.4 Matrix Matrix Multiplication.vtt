WEBVTT

1
00:00:00.190 --> 00:00:01.558
在这段视频中我们将会讨论

2
00:00:01.558 --> 00:00:03.577
矩阵 矩阵的乘法以及

3
00:00:03.580 --> 00:00:06.262
如何将两个矩阵相乘

4
00:00:06.590 --> 00:00:07.935
我们会使用这样一种方法

5
00:00:07.935 --> 00:00:09.412
在线性回归中用以解决

6
00:00:09.412 --> 00:00:11.251
参数计算的问题

7
00:00:11.251 --> 00:00:13.195
这种方法会把θ0、θ1等参数都放在一起来计算

8
00:00:13.195 --> 00:00:16.601
也就是说 我们不需要一个迭代的梯度下降算法

9
00:00:16.601 --> 00:00:18.005
当我们谈到这个算法的时候

10
00:00:18.005 --> 00:00:19.982
就会发现矩阵以及矩阵间的乘法运算

11
00:00:19.982 --> 00:00:23.086
是你必须理解的关键步骤之一

12
00:00:24.050 --> 00:00:27.885
所以让我们像往常那样 从一个例子开始

13
00:00:28.790 --> 00:00:30.558
比方说 我有两个矩阵

14
00:00:30.558 --> 00:00:33.060
我想将它们相乘

15
00:00:33.060 --> 00:00:34.343
让我先只是按照这个例子做一遍（乘法）

16
00:00:34.343 --> 00:00:37.441
然后告诉你这其中运算的细节

17
00:00:38.000 --> 00:00:39.154
那么  我要做的第一件事是

18
00:00:39.160 --> 00:00:40.589
我先把

19
00:00:40.589 --> 00:00:43.154
右边这个矩阵的第一列

20
00:00:43.170 --> 00:00:45.545
提取出来

21
00:00:46.340 --> 00:00:48.135
然后我将会把

22
00:00:48.135 --> 00:00:49.163
左边的这个矩阵和

23
00:00:49.170 --> 00:00:52.385
之前取出来的这一列（前面提过的，向量）相乘

24
00:00:52.385 --> 00:00:55.188
这只是第一列  是吧？

25
00:00:55.188 --> 00:00:56.385
然后我们可以看到 如果我

26
00:00:56.385 --> 00:00:59.067
这么做 我就会得到向量（11,9）

27
00:00:59.070 --> 00:01:02.068
所以这是与上个视频的矩阵

28
00:01:02.068 --> 00:01:05.932
和向量的乘法是一样的

29
00:01:05.950 --> 00:01:08.934
我已经提前算出了这个结果 是（11,9）

30
00:01:08.934 --> 00:01:10.519
那么 之后的第二件事

31
00:01:10.519 --> 00:01:12.811
我要做的就是

32
00:01:12.811 --> 00:01:14.752
我将把第二列再单独提出出来

33
00:01:14.752 --> 00:01:16.537
右边这个矩阵的第二列

34
00:01:16.537 --> 00:01:18.575
然后我将要把它和

35
00:01:18.575 --> 00:01:20.174
左边这个矩阵相乘

36
00:01:20.174 --> 00:01:21.398
是的吧  所以 这就是那个矩阵

37
00:01:21.410 --> 00:01:23.476
用右边的第二列

38
00:01:23.480 --> 00:01:24.902
来乘以这个矩阵

39
00:01:24.902 --> 00:01:26.360
因此 同样的 这是一个矩阵和

40
00:01:27.060 --> 00:01:28.960
向量的乘法运算  这

41
00:01:28.960 --> 00:01:30.643
就是你从上一个视频所学到的

42
00:01:30.643 --> 00:01:31.623
如果你这么做

43
00:01:31.623 --> 00:01:32.768
把这个矩阵和这个向量相乘

44
00:01:32.780 --> 00:01:34.250
你会得到

45
00:01:34.250 --> 00:01:36.214
（10,14）这个结果

46
00:01:36.214 --> 00:01:37.472
顺便说一下 如果你想练习

47
00:01:37.472 --> 00:01:39.776
矩阵和向量的乘法运算

48
00:01:39.776 --> 00:01:42.810
那么就先暂停下视频  自己算一算结果对不对

49
00:01:43.170 --> 00:01:44.248
好吧 现在我仅仅需要

50
00:01:44.248 --> 00:01:45.743
将得到的这两个结果放在一起

51
00:01:45.743 --> 00:01:48.398
那么这就是我的答案了

52
00:01:48.400 --> 00:01:49.962
那么 我们可以看到

53
00:01:49.962 --> 00:01:51.350
计算结果是

54
00:01:51.350 --> 00:01:53.449
一个2 x 2的矩阵

55
00:01:53.449 --> 00:01:54.467
我用来填充这个矩阵的方法

56
00:01:54.467 --> 00:01:56.294
就是

57
00:01:56.294 --> 00:01:57.914
把我的（11,9）

58
00:01:57.914 --> 00:02:00.137
填在这里

59
00:02:00.140 --> 00:02:03.753
把（10，14）填在

60
00:02:03.753 --> 00:02:06.386
第二列

61
00:02:06.720 --> 00:02:06.720
是的吧？

62
00:02:07.430 --> 00:02:08.824
所以 这就是如何

63
00:02:08.824 --> 00:02:11.086
将两个矩阵相乘的

64
00:02:11.086 --> 00:02:12.248
详细方法与过程

65
00:02:12.265 --> 00:02:14.094
每次你只需要看

66
00:02:14.094 --> 00:02:17.045
第二个矩阵的一列    然后把你的答案拼凑起来

67
00:02:17.070 --> 00:02:18.199
再次强调下 我们将一步步的来计算

68
00:02:18.199 --> 00:02:19.455
几秒中的时间里需要非常仔细

69
00:02:19.455 --> 00:02:20.754
但我也要指出

70
00:02:20.754 --> 00:02:22.852
我也要指出的是

71
00:02:22.852 --> 00:02:26.301
第一个例子是一个2X3矩阵

72
00:02:26.301 --> 00:02:28.548
乘以一个

73
00:02:28.550 --> 00:02:30.649
3x2的矩阵 他们相乘

74
00:02:30.649 --> 00:02:32.497
得到的结果

75
00:02:32.497 --> 00:02:35.518
是一个2x2的

76
00:02:35.518 --> 00:02:36.802
矩阵

77
00:02:36.802 --> 00:02:39.121
我们将很快知道为什么是这个结果

78
00:02:39.122 --> 00:02:40.484
好的

79
00:02:40.790 --> 00:02:42.637
这是计算的技巧

80
00:02:42.637 --> 00:02:43.745
让我们再看看

81
00:02:43.745 --> 00:02:44.953
这其中的细节

82
00:02:44.960 --> 00:02:46.305
看看究竟发生了什么

83
00:02:46.305 --> 00:02:48.082
下面就是详细的过程

84
00:02:48.082 --> 00:02:49.471
我有一个矩阵A

85
00:02:49.471 --> 00:02:51.325
我要把它乘以

86
00:02:51.350 --> 00:02:53.088
矩阵B  其结果

87
00:02:53.088 --> 00:02:56.143
会是一个新的矩阵C

88
00:02:56.143 --> 00:02:57.168
并且你会发现你只能

89
00:02:57.168 --> 00:02:59.238
相乘那些维度

90
00:02:59.238 --> 00:03:00.714
匹配的矩阵

91
00:03:00.714 --> 00:03:02.239
因此如果A是一个m×n的矩阵

92
00:03:02.240 --> 00:03:04.468
就是说m行n列

93
00:03:04.468 --> 00:03:05.394
我将要用它与

94
00:03:05.394 --> 00:03:06.480
一个n×o的矩阵相乘

95
00:03:06.500 --> 00:03:08.232
并且实际上这里的n

96
00:03:08.232 --> 00:03:10.306
必须匹配这里的这个n

97
00:03:10.330 --> 00:03:11.978
所以第一个矩阵的列的数目

98
00:03:11.978 --> 00:03:16.778
必须等于第二矩阵中的行的数目

99
00:03:16.800 --> 00:03:18.035
并且相乘得到的结果

100
00:03:18.035 --> 00:03:20.639
结果会是一个m×o的矩阵

101
00:03:20.639 --> 00:03:25.204
就像这个矩阵C这样

102
00:03:25.390 --> 00:03:26.822
并且 在前面的视频中

103
00:03:26.830 --> 00:03:28.743
我们所做的一切都符合这个规则

104
00:03:28.770 --> 00:03:31.380
这是一种当矩阵B的o值

105
00:03:31.380 --> 00:03:32.588
等于1的特殊情况（指的是矩阵和向量相乘）

106
00:03:32.588 --> 00:03:33.150
明白了吗？

107
00:03:33.150 --> 00:03:35.469
这是在B是一个向量的情况下

108
00:03:35.480 --> 00:03:36.522
但是现在 我们要处理

109
00:03:36.530 --> 00:03:39.805
O的值大于1的情况

110
00:03:39.805 --> 00:03:41.533
所以 这里就是你怎样

111
00:03:41.540 --> 00:03:44.564
把两个矩阵相乘

112
00:03:44.564 --> 00:03:46.349
为了得到结果

113
00:03:46.349 --> 00:03:47.775
我要做的就是

114
00:03:47.775 --> 00:03:49.180
我将要取

115
00:03:49.270 --> 00:03:52.025
B矩阵的第一列

116
00:03:52.025 --> 00:03:53.782
把取出的这列看成一个向量

117
00:03:53.782 --> 00:03:56.098
并乘以矩阵A

118
00:03:56.120 --> 00:03:57.909
用B矩阵的第一列

119
00:03:57.930 --> 00:03:59.632
这个计算结果将是

120
00:03:59.632 --> 00:04:00.370
m×1的矩阵（也就是一个向量）

121
00:04:00.400 --> 00:04:04.726
我们把结果先放在这里

122
00:04:05.070 --> 00:04:06.481
然后 我将要取

123
00:04:06.481 --> 00:04:09.048
B矩阵的

124
00:04:09.048 --> 00:04:11.920
第二列

125
00:04:12.010 --> 00:04:13.775
那么我会又得到一个n×1的向量

126
00:04:13.790 --> 00:04:15.501
也就是 这里的这一列

127
00:04:15.501 --> 00:04:16.690
这是正确的

128
00:04:16.690 --> 00:04:17.910
n×1的矩阵 也就是n维的向量

129
00:04:17.910 --> 00:04:19.782
我将要把这个矩阵

130
00:04:19.782 --> 00:04:21.678
和这些n乘1的向量相乘

131
00:04:21.678 --> 00:04:23.775
其结果将是

132
00:04:23.775 --> 00:04:26.018
一个m维的向量

133
00:04:26.450 --> 00:04:28.035
然后我会把结果先放在那里

134
00:04:28.035 --> 00:04:29.273
依此类推

135
00:04:29.273 --> 00:04:30.035
对吧？

136
00:04:30.035 --> 00:04:31.135
那么 你知道的

137
00:04:31.135 --> 00:04:32.099
我开始取第三列

138
00:04:32.099 --> 00:04:33.475
把它和这个矩阵相乘

139
00:04:33.475 --> 00:04:37.507
我又得到了一个M维向量

140
00:04:37.510 --> 00:04:39.368
依此类推 直到你计算到了

141
00:04:39.368 --> 00:04:40.610
最后一列

142
00:04:40.610 --> 00:04:41.870
矩阵乘以

143
00:04:41.950 --> 00:04:43.420
你取到的最后一列

144
00:04:43.530 --> 00:04:45.757
就是C的最后一列

145
00:04:46.460 --> 00:04:48.808
再说一遍

146
00:04:49.310 --> 00:04:51.510
矩阵C的第i列

147
00:04:51.600 --> 00:04:53.777
是根据把

148
00:04:53.810 --> 00:04:56.108
矩阵A与

149
00:04:56.110 --> 00:04:57.641
矩阵B的第i列

150
00:04:57.660 --> 00:04:59.638
相乘得到的

151
00:04:59.638 --> 00:05:01.539
结果

152
00:05:01.560 --> 00:05:03.387
依次相加

153
00:05:03.387 --> 00:05:04.936
从1,2到o依次相加的 对吧？

154
00:05:04.950 --> 00:05:06.752
那么 我们在这里做一个总结

155
00:05:06.760 --> 00:05:08.765
我们总结了我们为了

156
00:05:08.765 --> 00:05:10.163
计算矩阵C所做的步骤

157
00:05:10.163 --> 00:05:12.909
让我们再看一个例子

158
00:05:12.940 --> 00:05:17.235
比方说我想把这两个矩阵相乘

159
00:05:17.235 --> 00:05:18.208
那么我首先要做的是

160
00:05:18.208 --> 00:05:20.178
先取出

161
00:05:20.178 --> 00:05:22.535
我的第二个矩阵的

162
00:05:22.535 --> 00:05:24.370
第一列

163
00:05:24.370 --> 00:05:26.185
就是这个矩阵B 这就是

164
00:05:26.185 --> 00:05:29.133
上一张幻灯片上出现的矩阵B

165
00:05:29.160 --> 00:05:30.660
因此 我就这么

166
00:05:30.660 --> 00:05:32.917
用矩阵和我取的向量相乘

167
00:05:32.920 --> 00:05:35.350
所以    让我们快速的计算这个结果

168
00:05:35.350 --> 00:05:37.518
这等于

169
00:05:37.518 --> 00:05:39.048
没错  （1,3）乘以（0,3）

170
00:05:39.048 --> 00:05:41.238
所以 就是

171
00:05:41.270 --> 00:05:45.930
1x0+3x3（9）

172
00:05:45.930 --> 00:05:48.322
此外 第二元素

173
00:05:48.322 --> 00:05:49.530
就是（2，5）

174
00:05:49.530 --> 00:05:51.678
乘以（0，3）

175
00:05:51.678 --> 00:05:52.739
就是0x2+5x3（15）

176
00:05:52.740 --> 00:05:57.276
那么结果出来了

177
00:05:57.276 --> 00:06:02.242
（9,15）实际上该用绿色的颜色标记

178
00:06:02.242 --> 00:06:03.672
所以这就是（9.15）

179
00:06:03.672 --> 00:06:09.365
那么

180
00:06:09.365 --> 00:06:12.061
我将同样的取出

181
00:06:12.090 --> 00:06:14.451
这个的第二列

182
00:06:14.451 --> 00:06:16.174
做相同的计算

183
00:06:16.190 --> 00:06:18.170
所以

184
00:06:18.200 --> 00:06:20.477
这是这个矩阵乘以（1,2）

185
00:06:20.477 --> 00:06:22.288
让我们快点算吧

186
00:06:22.290 --> 00:06:23.814
所以这是

187
00:06:23.814 --> 00:06:27.362
1x1 + 3x2

188
00:06:27.362 --> 00:06:28.973
那么这就处理了这一行

189
00:06:28.973 --> 00:06:30.868
让我们计算另一行

190
00:06:30.868 --> 00:06:34.223
让我们来看看

191
00:06:34.223 --> 00:06:37.510
这次是

192
00:06:37.510 --> 00:06:41.926
2x1 + 5x2

193
00:06:41.926 --> 00:06:43.493
因此这就等于

194
00:06:43.493 --> 00:06:46.176
我们看一下

195
00:06:46.176 --> 00:06:47.464
1x1 + 3x1结果是4

196
00:06:47.464 --> 00:06:50.378
2x1 + 5x2

197
00:06:50.378 --> 00:06:52.282
结果是

198
00:06:52.282 --> 00:06:53.923
12

199
00:06:55.570 --> 00:06:56.660
所以现在我有两个这个了

200
00:06:56.660 --> 00:06:58.448
因此我得到的

201
00:06:58.448 --> 00:07:00.343
这两个矩阵

202
00:07:00.343 --> 00:07:01.714
相乘的结果就是

203
00:07:01.714 --> 00:07:03.831
这个在这儿

204
00:07:03.831 --> 00:07:07.232
那个放那边

205
00:07:07.232 --> 00:07:09.828
所以我得到了

206
00:07:09.828 --> 00:07:14.632
9,15和

207
00:07:14.660 --> 00:07:17.831
4,12

208
00:07:17.831 --> 00:07:19.657
你也可能会注意到这个结果

209
00:07:19.670 --> 00:07:21.616
一个2×2的矩阵

210
00:07:21.616 --> 00:07:23.687
乘以另一个2x2的矩阵

211
00:07:23.687 --> 00:07:25.215
这个维度会是

212
00:07:25.215 --> 00:07:26.609
第一个矩阵的2乘以第二的矩阵的2

213
00:07:26.609 --> 00:07:28.415
所以这个结果本身

214
00:07:28.430 --> 00:07:31.460
也是一个2x2的矩阵

215
00:07:35.000 --> 00:07:36.304
最后让我告诉你

216
00:07:36.304 --> 00:07:37.795
一个更加具体的技巧    你可以

217
00:07:37.795 --> 00:07:40.699
在矩阵和矩阵的乘法中使用

218
00:07:40.980 --> 00:07:42.455
比方说 在这之前 我们

219
00:07:42.455 --> 00:07:45.823
有四间房子

220
00:07:45.823 --> 00:07:47.970
我们要预测其价格

221
00:07:48.410 --> 00:07:49.825
但是现在我们有三个

222
00:07:49.825 --> 00:07:51.967
不同的竞争假设集在这儿

223
00:07:51.970 --> 00:07:54.145
在右侧 因此 如果

224
00:07:54.145 --> 00:07:55.720
你想要去把

225
00:07:55.720 --> 00:07:57.745
这三个竞争假设集用来

226
00:07:57.745 --> 00:07:58.951
适应这4个房屋的数据

227
00:07:58.951 --> 00:07:59.926
那么你可以这样做

228
00:07:59.926 --> 00:08:01.718
这将非常高效

229
00:08:01.718 --> 00:08:05.080
我们使用这里的矩阵乘法来计算

230
00:08:05.110 --> 00:08:07.347
左边是我通常使用的矩阵

231
00:08:07.370 --> 00:08:08.626
这与我上个视频

232
00:08:08.626 --> 00:08:11.063
一样  这些值就是

233
00:08:11.063 --> 00:08:15.012
我的住房价格   我把这些值也放在左边

234
00:08:15.012 --> 00:08:16.626
那么 我要去做的就是

235
00:08:16.626 --> 00:08:19.029
构造另一个矩阵

236
00:08:19.110 --> 00:08:21.693
这个矩阵的第一列

237
00:08:21.700 --> 00:08:23.477
是-40

238
00:08:23.480 --> 00:08:26.062
0.25

239
00:08:26.070 --> 00:08:28.372
第二列是

240
00:08:28.372 --> 00:08:30.945
（200.0.1）

241
00:08:31.460 --> 00:08:34.278
以此类推

242
00:08:34.278 --> 00:08:35.925
事实证明  如果你

243
00:08:35.925 --> 00:08:37.893
把这两个矩阵相乘

244
00:08:37.910 --> 00:08:40.448
你就会发现得到了结果的

245
00:08:40.448 --> 00:08:43.467
第一列  你知道的

246
00:08:43.467 --> 00:08:46.340
那么你怎么得到这个第一列呢？

247
00:08:46.400 --> 00:08:48.850
这就要用到我们讲过的

248
00:08:48.850 --> 00:08:50.565
矩阵和矩阵相乘的过程

249
00:08:50.565 --> 00:08:51.945
你得到的这个矩阵的第一列

250
00:08:51.960 --> 00:08:53.360
通过你用这个矩阵

251
00:08:53.420 --> 00:08:54.816
乘以

252
00:08:54.840 --> 00:08:56.724
这个矩阵的第一列

253
00:08:56.724 --> 00:08:58.540
这是我们从之前的视频中看到过的

254
00:08:58.540 --> 00:09:00.472
这就是从第一个假设

255
00:09:00.490 --> 00:09:02.050
预测出的

256
00:09:02.150 --> 00:09:05.701
住房价格 对吗？

257
00:09:05.701 --> 00:09:08.775
就是这里的这个假设集

258
00:09:08.790 --> 00:09:10.794
那么 第二列是什么呢？

259
00:09:10.794 --> 00:09:12.955
那么 我们应该怎么计算第二列呢？

260
00:09:12.990 --> 00:09:14.332
用来得到第二列的方法

261
00:09:14.332 --> 00:09:15.548
就是

262
00:09:15.590 --> 00:09:19.270
用这个矩阵乘以这个矩阵的第二列

263
00:09:19.270 --> 00:09:21.293
那么得到的第二列就是

264
00:09:21.293 --> 00:09:24.651
基于第二个假设

265
00:09:24.651 --> 00:09:27.728
做出的预测结果

266
00:09:27.750 --> 00:09:30.228
第二个假设集是在那里

267
00:09:30.228 --> 00:09:34.450
对于第三列 我们也能得到类似的结果

268
00:09:34.450 --> 00:09:35.809
那么 我并没有

269
00:09:35.810 --> 00:09:38.058
把详细的细节列出

270
00:09:38.058 --> 00:09:39.139
不过 我还是希望你们能够把

271
00:09:39.140 --> 00:09:40.448
视频暂停下 自己算一算

272
00:09:40.448 --> 00:09:41.786
检查下结果对不对

273
00:09:41.786 --> 00:09:43.972
检验下我刚才计算的结果的正确性

274
00:09:43.990 --> 00:09:45.611
那么 实际上通过

275
00:09:45.611 --> 00:09:47.454
构建这两个矩阵

276
00:09:47.454 --> 00:09:48.937
你就可以

277
00:09:48.940 --> 00:09:51.180
快速的把这三个假设集

278
00:09:51.180 --> 00:09:52.602
应用到所有四个

279
00:09:52.602 --> 00:09:54.455
房子的尺寸中来计算价格了

280
00:09:54.455 --> 00:09:56.452
你看 所有的12种预测到的价格是

281
00:09:56.452 --> 00:09:57.721
通过你的假设集

282
00:09:57.721 --> 00:10:00.928
以及你的四个房屋数据集得到的

283
00:10:00.928 --> 00:10:03.366
所以 一次矩阵乘法操作

284
00:10:03.366 --> 00:10:05.072
就使你做出了12种预测

285
00:10:05.080 --> 00:10:07.130
更好的是

286
00:10:07.130 --> 00:10:08.446
事实证明

287
00:10:08.446 --> 00:10:09.937
为了做到

288
00:10:09.937 --> 00:10:11.408
矩阵间的乘法

289
00:10:11.408 --> 00:10:13.130
有很多很好的线性代数库函数

290
00:10:13.150 --> 00:10:14.767
都是为了做到这一点

291
00:10:14.767 --> 00:10:16.676
为你实现矩阵乘法

292
00:10:16.676 --> 00:10:18.250
而且不管你用的是

293
00:10:18.250 --> 00:10:22.025
多么合理的编程语言

294
00:10:22.025 --> 00:10:24.005
当然 当下最流行的

295
00:10:24.005 --> 00:10:27.898
编程语言中的前十名都有很棒的线性代数函数库

296
00:10:27.898 --> 00:10:29.554
这是很好的事情

297
00:10:29.554 --> 00:10:31.463
我们能够在高度优化下

298
00:10:31.463 --> 00:10:33.415
做到矩阵

299
00:10:33.440 --> 00:10:36.531
和矩阵间高效的乘法 包括

300
00:10:36.531 --> 00:10:38.501
采取了一些优化处理的方式

301
00:10:38.501 --> 00:10:41.119
如并行计算

302
00:10:41.130 --> 00:10:42.886
如果你的电脑支持的话

303
00:10:42.886 --> 00:10:46.297
当你的计算机有多个

304
00:10:46.330 --> 00:10:48.016
调度或者

305
00:10:48.016 --> 00:10:49.866
多个处理器  一个处理器内有时

306
00:10:49.866 --> 00:10:53.285
存在并行的计算 我们称之为SIMD Parallelism

307
00:10:53.285 --> 00:10:55.242
在计算机管理机制下

308
00:10:55.242 --> 00:10:56.727
你应该有

309
00:10:56.730 --> 00:10:58.826
非常不错的免费类库

310
00:10:58.826 --> 00:11:00.146
你可以用来做

311
00:11:00.146 --> 00:11:02.326
高效的矩阵间的乘法计算

312
00:11:02.326 --> 00:11:04.104
因此你就能

313
00:11:04.110 --> 00:11:05.908
你知道的

314
00:11:05.930 --> 00:11:08.738
方便地计算有很多假设集时的预测数据
【教育无边界字幕组】翻译：Naplessss  校对：home1888 审核：所罗门捷列夫