WEBVTT

1
00:00:00.280 --> 00:00:04.479
在这段视频中 我将介绍有关向量化的内容

2
00:00:04.480 --> 00:00:06.471
无论你是用Octave

3
00:00:06.471 --> 00:00:08.277
还是别的语言 比如MATLAB

4
00:00:08.277 --> 00:00:09.604
或者你正在用Python

5
00:00:09.604 --> 00:00:12.520
NumPy 或 Java C C++

6
00:00:12.520 --> 00:00:14.850
所有这些语言都具有

7
00:00:14.850 --> 00:00:16.708
各种线性代数库

8
00:00:16.720 --> 00:00:19.439
这些库文件都是内置的

9
00:00:19.439 --> 00:00:21.806
容易阅读和获取

10
00:00:21.820 --> 00:00:23.335
他们通常写得很好

11
00:00:23.335 --> 00:00:25.695
已经经过高度优化

12
00:00:25.695 --> 00:00:29.181
通常是数值计算方面的博士

13
00:00:29.181 --> 00:00:32.075
或者专业人士开发的

14
00:00:32.075 --> 00:00:33.944
而当你实现机器学习算法时

15
00:00:33.960 --> 00:00:35.904
如果你能

16
00:00:35.930 --> 00:00:37.797
好好利用这些

17
00:00:37.810 --> 00:00:39.296
线性代数库或者说

18
00:00:39.310 --> 00:00:41.600
数值线性代数库

19
00:00:41.620 --> 00:00:43.387
并联合调用它们

20
00:00:43.387 --> 00:00:45.172
而不是自己去做那些

21
00:00:45.180 --> 00:00:48.029
函数库可以做的事情

22
00:00:48.040 --> 00:00:49.612
如果是这样的话 那么

23
00:00:49.612 --> 00:00:51.872
通常你会发现 首先 这样更有效

24
00:00:51.880 --> 00:00:53.179
也就是说运行速度更快

25
00:00:53.179 --> 00:00:54.891
并且更好地利用

26
00:00:54.891 --> 00:00:56.631
你的计算机里可能有的一些并行硬件系统

27
00:00:56.631 --> 00:00:58.254
等等

28
00:00:58.270 --> 00:01:00.533
第二 这也意味着

29
00:01:00.540 --> 00:01:03.075
你可以用更少的代码来实现你需要的功能

30
00:01:03.075 --> 00:01:04.962
因此 实现的方式更简单

31
00:01:04.962 --> 00:01:08.532
代码出现问题的有可能性也就越小

32
00:01:08.550 --> 00:01:10.534
举个具体的例子

33
00:01:10.570 --> 00:01:12.726
与其自己写代码

34
00:01:12.726 --> 00:01:15.061
做矩阵乘法

35
00:01:15.061 --> 00:01:16.300
如果你只在Octave中

36
00:01:16.300 --> 00:01:18.145
输入 a乘以b

37
00:01:18.145 --> 00:01:19.833
就是一个非常有效的

38
00:01:19.833 --> 00:01:22.318
两个矩阵相乘的程序

39
00:01:22.340 --> 00:01:23.985
有很多例子可以说明

40
00:01:24.010 --> 00:01:27.220
如果你用合适的向量化方法来实现

41
00:01:27.220 --> 00:01:30.062
你就会有一个简单得多 也有效得多的代码

42
00:01:30.280 --> 00:01:33.071
让我们来看一些例子

43
00:01:33.071 --> 00:01:34.937
这是一个常见的线性回归假设函数

44
00:01:34.937 --> 00:01:36.415
如果

45
00:01:36.415 --> 00:01:37.348
你想要计算 h(x)

46
00:01:37.348 --> 00:01:40.032
注意到右边是求和

47
00:01:40.032 --> 00:01:41.130
那么你可以

48
00:01:41.130 --> 00:01:42.775
自己计算

49
00:01:42.775 --> 00:01:46.611
j =0 到 j = n 的和

50
00:01:46.620 --> 00:01:48.000
但换另一种方式来想想

51
00:01:48.000 --> 00:01:49.210
是把 h(x) 看作

52
00:01:49.210 --> 00:01:52.029
θ 转置乘以 x

53
00:01:52.029 --> 00:01:53.262
那么

54
00:01:53.262 --> 00:01:55.654
你就可以写成

55
00:01:55.660 --> 00:01:57.823
两个向量的内积

56
00:01:57.840 --> 00:02:00.135
其中 θ 就是

57
00:02:00.135 --> 00:02:01.784
θ0  θ1

58
00:02:01.800 --> 00:02:04.812
θ2 如果你有两个特征量

59
00:02:04.812 --> 00:02:06.410
如果 n 等于2 并且如果

60
00:02:06.450 --> 00:02:08.133
你把 x 看作

61
00:02:08.133 --> 00:02:11.810
x0 x1 x2

62
00:02:11.884 --> 00:02:13.952
这两种思考角度

63
00:02:13.952 --> 00:02:17.539
会给你两种不同的实现方式

64
00:02:17.560 --> 00:02:18.909
比如说

65
00:02:18.909 --> 00:02:21.012
这是未向量化的代码实现方式

66
00:02:21.040 --> 00:02:22.454
计算 h(x) 是未向量化的

67
00:02:22.454 --> 00:02:26.120
我的意思是 没有被向量化

68
00:02:26.130 --> 00:02:29.479
我们可能首先要初始化变量 prediction 的值为0.0

69
00:02:29.479 --> 00:02:32.383
而这个

70
00:02:32.383 --> 00:02:34.287
变量 prediction 的最终结果就是

71
00:02:34.300 --> 00:02:36.090
h(x) 然后

72
00:02:36.090 --> 00:02:37.258
我要用一个 for 循环

73
00:02:37.270 --> 00:02:38.354
j 取值 0 到 n+1

74
00:02:38.354 --> 00:02:40.792
变量prediction 每次就通过

75
00:02:40.792 --> 00:02:41.822
自身加上 theta(j) 乘以 x(j) 更新值

76
00:02:41.822 --> 00:02:44.737
这个就是算法的代码实现

77
00:02:44.737 --> 00:02:47.223
顺便我要提醒一下

78
00:02:47.223 --> 00:02:48.894
这里的向量

79
00:02:48.900 --> 00:02:51.102
我用的下标是 0

80
00:02:51.110 --> 00:02:52.600
所以我有 θ0 θ1

81
00:02:52.600 --> 00:02:54.390
θ2 但因为 MATLAB

82
00:02:54.390 --> 00:02:56.713
的下标从1开始 在 MATLAB 中 θ0

83
00:02:56.713 --> 00:02:58.019
我们可能会

84
00:02:58.019 --> 00:03:00.204
用 theta(1) 来表示

85
00:03:00.204 --> 00:03:02.042
这第二个元素

86
00:03:02.042 --> 00:03:04.392
最后就会变成

87
00:03:04.392 --> 00:03:05.862
theta(2) 而第三个元素

88
00:03:05.880 --> 00:03:08.002
最终可能就用

89
00:03:08.002 --> 00:03:09.952
theta(3) 表示 因为

90
00:03:09.960 --> 00:03:11.998
MATLAB 中的下标从1开始

91
00:03:11.998 --> 00:03:13.525
即使我们实际的

92
00:03:13.525 --> 00:03:15.436
θ 和 x 的下标从0开始

93
00:03:15.450 --> 00:03:17.002
这就是为什么

94
00:03:17.002 --> 00:03:18.785
这里我的 for 循环

95
00:03:18.785 --> 00:03:20.498
j 取值从 1 直到 n+1

96
00:03:20.498 --> 00:03:22.225
而不是

97
00:03:22.225 --> 00:03:26.243
从 0 到 n 清楚了吗？

98
00:03:26.300 --> 00:03:27.870
但这是一个

99
00:03:27.870 --> 00:03:29.571
未向量化的代码实现方式

100
00:03:29.571 --> 00:03:31.373
我们用一个 for 循环

101
00:03:31.373 --> 00:03:34.018
对 n 个元素进行加和

102
00:03:34.050 --> 00:03:35.646
作为比较 接下来是

103
00:03:35.646 --> 00:03:38.400
向量化的代码实现

104
00:03:38.410 --> 00:03:39.959
你把

105
00:03:39.959 --> 00:03:42.618
x 和 θ

106
00:03:42.618 --> 00:03:43.955
看做向量 而你只需要

107
00:03:43.955 --> 00:03:46.039
令变量 prediction 等于 theta转置

108
00:03:46.039 --> 00:03:48.347
乘以 x 你就可以这样计算

109
00:03:48.360 --> 00:03:51.011
与其写所有这些

110
00:03:51.011 --> 00:03:52.966
for 循环的代码

111
00:03:52.966 --> 00:03:54.242
你只需要一行代码

112
00:03:54.242 --> 00:03:56.648
这行代码

113
00:03:56.648 --> 00:03:57.555
右边所做的

114
00:03:57.555 --> 00:03:59.237
就是

115
00:03:59.237 --> 00:04:01.829
利用 Octave 的高度优化的数值

116
00:04:01.840 --> 00:04:03.859
线性代数算法来计算

117
00:04:03.859 --> 00:04:06.245
两个向量的内积

118
00:04:06.245 --> 00:04:08.186
θ 以及 x

119
00:04:08.190 --> 00:04:10.182
这样向量化的实现不仅仅是更简单

120
00:04:10.182 --> 00:04:14.664
它运行起来也将更加高效

121
00:04:15.820 --> 00:04:17.792
这就是 Octave 所做的

122
00:04:17.792 --> 00:04:19.912
而向量化的方法

123
00:04:19.920 --> 00:04:22.020
在其他编程语言中同样可以实现

124
00:04:22.040 --> 00:04:24.947
让我们来看一个 C++ 的例子

125
00:04:24.947 --> 00:04:27.965
这就是未向量化的代码实现的样子

126
00:04:27.965 --> 00:04:31.395
我们再次初始化变量 prediction 为 0.0

127
00:04:31.395 --> 00:04:32.518
然后我们现在有一个完整的

128
00:04:32.518 --> 00:04:34.508
从 j 等于 0 直到 n

129
00:04:34.508 --> 00:04:36.819
变量 prediction +=

130
00:04:36.830 --> 00:04:38.546
theta[j] 乘以 x[j]

131
00:04:38.560 --> 00:04:42.777
再一次 你有这样的自己写的 for 循环

132
00:04:42.777 --> 00:04:44.843
与此相反 使用一个比较好的

133
00:04:44.850 --> 00:04:46.498
C++ 数值线性代数库

134
00:04:46.498 --> 00:04:48.965
你就可以用这个方程

135
00:04:48.990 --> 00:04:54.440
来写这个函数

136
00:04:54.560 --> 00:04:56.533
与此相反 使用较好的

137
00:04:56.533 --> 00:04:58.152
C++ 数值线性代数库

138
00:04:58.152 --> 00:05:00.686
你可以写出

139
00:05:00.686 --> 00:05:02.470
像这样的代码

140
00:05:02.470 --> 00:05:03.985
因此取决于你的

141
00:05:03.985 --> 00:05:05.595
数值线性代数库的内容

142
00:05:05.595 --> 00:05:06.790
你可以有一个对象 (object)

143
00:05:06.830 --> 00:05:08.580
像这个

144
00:05:08.580 --> 00:05:09.918
C++ 对象

145
00:05:09.918 --> 00:05:11.328
theta 和一个 C++

146
00:05:11.350 --> 00:05:13.436
对象 向量 x

147
00:05:13.436 --> 00:05:15.552
你只需要用 theta.transpose ( )

148
00:05:15.552 --> 00:05:18.115
乘以 x

149
00:05:18.120 --> 00:05:20.092
而这次是让 C++ 来实现运算

150
00:05:20.092 --> 00:05:22.028
因此

151
00:05:22.028 --> 00:05:26.156
你只需要在 C++ 中将两个向量相乘

152
00:05:26.156 --> 00:05:28.091
根据你所使用的

153
00:05:28.110 --> 00:05:29.515
数值和线性代数库的使用细节的不同

154
00:05:29.515 --> 00:05:30.855
你最终使用的代码表达方式

155
00:05:30.855 --> 00:05:31.894
可能会有些许不同

156
00:05:31.894 --> 00:05:33.636
但是通过

157
00:05:33.636 --> 00:05:35.758
一个库来做内积

158
00:05:35.760 --> 00:05:37.064
你可以得到一段更简单

159
00:05:37.064 --> 00:05:40.623
更有效的代码

160
00:05:40.623 --> 00:05:43.582
现在 让我们来看一个更为复杂的例子

161
00:05:43.582 --> 00:05:45.015
提醒一下

162
00:05:45.015 --> 00:05:46.792
这是线性回归算法梯度下降的更新规则

163
00:05:46.792 --> 00:05:48.794
所以

164
00:05:48.794 --> 00:05:50.488
我们用这条规则对 j 等于 0 1 2 等等的所有值

165
00:05:50.488 --> 00:05:53.672
更新 对象 θj

166
00:05:53.672 --> 00:05:56.259
我只是

167
00:05:56.260 --> 00:05:58.206
用 θ0 θ1 θ2 

168
00:05:58.206 --> 00:06:00.048
来写方程

169
00:06:00.048 --> 00:06:02.173
那就是假设我们有两个特征量

170
00:06:02.173 --> 00:06:03.469
所以 n等于2

171
00:06:03.469 --> 00:06:04.607
这些都是我们需要对

172
00:06:04.610 --> 00:06:07.388
θ0 θ1 θ2 进行更新

173
00:06:07.410 --> 00:06:08.982
你可能还记得

174
00:06:08.982 --> 00:06:10.825
在以前的视频中说过

175
00:06:10.825 --> 00:06:14.783
这些都应该是同步更新

176
00:06:14.783 --> 00:06:16.268
因此 让我们来看看

177
00:06:16.268 --> 00:06:17.725
我们是否可以拿出一个

178
00:06:17.725 --> 00:06:20.723
向量化的代码实现

179
00:06:20.740 --> 00:06:22.598
这里是和之前相同的三个方程

180
00:06:22.598 --> 00:06:24.182
只不过写得小一点而已

181
00:06:24.182 --> 00:06:25.517
你可以想象

182
00:06:25.520 --> 00:06:26.716
实现这三个方程的方式之一

183
00:06:26.720 --> 00:06:27.798
就是用

184
00:06:27.798 --> 00:06:28.968
一个 for 循环

185
00:06:28.968 --> 00:06:31.682
就是让 j 等于0

186
00:06:31.682 --> 00:06:33.305
等于 等于2

187
00:06:33.305 --> 00:06:35.603
来更新 θj

188
00:06:35.603 --> 00:06:36.760
但让我们

189
00:06:36.760 --> 00:06:40.975
用向量化的方式来实现 看看我们是否能够有一个更简单的方法

190
00:06:40.975 --> 00:06:42.711
基本上用三行代码

191
00:06:42.757 --> 00:06:44.314
或者一个 for 循环

192
00:06:44.314 --> 00:06:48.518
一次实现这三个方程

193
00:06:48.518 --> 00:06:49.688
让我们来看看怎样能用这三步

194
00:06:49.688 --> 00:06:51.402
并将它们压缩成

195
00:06:51.402 --> 00:06:53.972
一行向量化的代码来实现

196
00:06:53.976 --> 00:06:55.476
做法如下

197
00:06:55.480 --> 00:06:56.462
我打算

198
00:06:56.462 --> 00:06:59.131
把 θ 看做一个向量

199
00:06:59.131 --> 00:07:00.633
然后我用

200
00:07:00.633 --> 00:07:04.214
θ 减去

201
00:07:04.270 --> 00:07:07.468
α 乘以 某个别的向量

202
00:07:07.468 --> 00:07:11.650
δ 来更新 θ

203
00:07:11.650 --> 00:07:13.689
这里的 δ 等于

204
00:07:13.700 --> 00:07:15.876
 m 分之 1

205
00:07:15.876 --> 00:07:18.408
对 i=1 到 m 

206
00:07:18.450 --> 00:07:22.151
进行求和

207
00:07:22.180 --> 00:07:25.570
然后这个表达式

208
00:07:25.720 --> 00:07:28.118
对吧?

209
00:07:28.118 --> 00:07:31.205
让我解释一下是怎么回事

210
00:07:31.220 --> 00:07:32.666
在这里 我要把

211
00:07:32.666 --> 00:07:35.322
θ 看作一个向量

212
00:07:35.350 --> 00:07:38.106
有一个 n+1 维向量

213
00:07:38.110 --> 00:07:40.291
我是说 θ 被更新

214
00:07:40.310 --> 00:07:43.922
我们的 n+1 维向量

215
00:07:43.922 --> 00:07:45.319
α 是一个实数

216
00:07:45.319 --> 00:07:47.395
δ 在这里

217
00:07:47.410 --> 00:07:49.941
是一个向量

218
00:07:49.960 --> 00:07:54.278
所以这个减法运算是一个向量减法

219
00:07:54.278 --> 00:07:55.255
没问题吧 ?

220
00:07:55.255 --> 00:07:56.977
因为 α 乘以 δ

221
00:07:56.977 --> 00:07:58.385
是一个向量 所以

222
00:07:58.385 --> 00:08:00.369
θ 就是

223
00:08:00.369 --> 00:08:04.217
 θ 减去 α 乘以 δ 得到的向量

224
00:08:04.240 --> 00:08:06.563
那么什么是向量 δ 呢 ?

225
00:08:06.563 --> 00:08:10.220
嗯 向量 δ 是这样子的

226
00:08:10.256 --> 00:08:12.092
这部分实际上

227
00:08:12.092 --> 00:08:14.595
代表的就是

228
00:08:14.620 --> 00:08:17.102
这部分内容

229
00:08:17.140 --> 00:08:19.200
具体地说 δ 将成为

230
00:08:19.220 --> 00:08:22.165
n+1 维向量

231
00:08:22.165 --> 00:08:23.978
并且向量的第一个元素

232
00:08:23.978 --> 00:08:27.767
就等于这个

233
00:08:27.770 --> 00:08:29.513
所以我们的 δ

234
00:08:29.513 --> 00:08:31.565
如果要写下标的话

235
00:08:31.565 --> 00:08:34.469
就是从零开始 δ0 δ1 δ2

236
00:08:34.469 --> 00:08:36.541
我想要的是

237
00:08:36.560 --> 00:08:39.033
δ0 等于

238
00:08:39.040 --> 00:08:41.267
这个

239
00:08:41.267 --> 00:08:42.359
第一行绿色框起来的部分

240
00:08:42.360 --> 00:08:45.306
事实上 你可能会

241
00:08:45.306 --> 00:08:47.108
写出 δ0 是

242
00:08:47.108 --> 00:08:48.681
m 分之 1

243
00:08:48.681 --> 00:08:50.102
乘以 h(x(i)) 

244
00:08:50.102 --> 00:08:53.356
减去 y(i)

245
00:08:53.400 --> 00:08:58.315
乘以 x(i)0 的求和

246
00:08:58.315 --> 00:08:59.748
所以让我们

247
00:08:59.748 --> 00:09:01.064
在同一页上

248
00:09:01.064 --> 00:09:03.998
计算真正的 δ

249
00:09:03.998 --> 00:09:05.488
δ 就是 m 分之 1

250
00:09:05.488 --> 00:09:08.284
乘以这个和

251
00:09:08.284 --> 00:09:09.871
那这个和是什么 ?

252
00:09:09.871 --> 00:09:11.426
嗯 这一项

253
00:09:11.426 --> 00:09:17.115
是一个实数

254
00:09:17.150 --> 00:09:21.219
这里的第二个项 是 x(i)

255
00:09:21.219 --> 00:09:23.892
这一项是一个向量

256
00:09:23.910 --> 00:09:26.109
对吧 ? 因为 x(i)

257
00:09:26.109 --> 00:09:26.982
可能是一个向量

258
00:09:26.990 --> 00:09:29.630
这将是

259
00:09:29.975 --> 00:09:36.115
x(i)0 x(i)1 x(i)2 对吧 ?

260
00:09:36.130 --> 00:09:38.246
那这个求和是什么 ?

261
00:09:38.246 --> 00:09:40.241
嗯 这个求和就是

262
00:09:40.250 --> 00:09:43.292
这里的式子

263
00:09:43.502 --> 00:09:46.555
这里的这一项

264
00:09:47.280 --> 00:09:54.801
等于 h(x(1)) - y(1) 乘以 x(1)

265
00:09:54.870 --> 00:09:59.099
加上

266
00:09:59.115 --> 00:10:02.778
h(x(2)) - y(2) 乘以 x(2)

267
00:10:02.778 --> 00:10:05.396
依此类推

268
00:10:05.396 --> 00:10:06.404
对吧 ?

269
00:10:06.404 --> 00:10:07.420
因为这是对 i 的加和

270
00:10:07.420 --> 00:10:09.013
所以

271
00:10:09.013 --> 00:10:11.345
当 i 从 1 到 m

272
00:10:11.345 --> 00:10:15.144
你就会得到这些不同的式子 然后作加和

273
00:10:15.160 --> 00:10:16.221
每个式子的意思

274
00:10:16.221 --> 00:10:18.262
很像

275
00:10:18.262 --> 00:10:19.807
如果你还记得实际上

276
00:10:19.807 --> 00:10:24.100
在以前的一个小测验 如果你要解这个方程

277
00:10:24.110 --> 00:10:25.560
我们说过

278
00:10:25.560 --> 00:10:27.250
为了向量化这段代码

279
00:10:27.250 --> 00:10:30.755
我们会令 u = 2v +5w 因此

280
00:10:30.770 --> 00:10:32.391
我们说 向量u

281
00:10:32.391 --> 00:10:33.706
等于2乘以向量v

282
00:10:33.706 --> 00:10:35.568
加上 5乘以向量 w

283
00:10:35.570 --> 00:10:37.198
用这个例子说明

284
00:10:37.198 --> 00:10:39.023
如何对不同的向量进行相加

285
00:10:39.023 --> 00:10:42.453
这里的求和是同样的道理

286
00:10:42.453 --> 00:10:44.919
这一部分

287
00:10:44.950 --> 00:10:49.766
只是一个实数

288
00:10:49.840 --> 00:10:50.996
就有点像数字 2

289
00:10:51.010 --> 00:10:52.698
而这里是别的一些数字

290
00:10:52.711 --> 00:10:54.085
来乘以向量x1

291
00:10:54.085 --> 00:10:56.792
这就像是 2v

292
00:10:56.792 --> 00:10:59.177
只不过用别的数字乘以 x1

293
00:10:59.177 --> 00:11:01.712
然后加上 你知道

294
00:11:01.712 --> 00:11:03.475
不是5w 而是用

295
00:11:03.475 --> 00:11:05.212
别的实数乘以

296
00:11:05.212 --> 00:11:06.850
一个别的向量 然后你

297
00:11:06.860 --> 00:11:08.909
加上

298
00:11:08.909 --> 00:11:10.528
其他的向量

299
00:11:10.540 --> 00:11:12.234
这就是为什么

300
00:11:12.234 --> 00:11:15.178
总体而言

301
00:11:15.178 --> 00:11:17.015
在这里 这整个量

302
00:11:17.015 --> 00:11:19.745
δ 就是一个向量

303
00:11:19.770 --> 00:11:23.685
具体而言

304
00:11:23.685 --> 00:11:26.373
对应这三个 δ 的元素

305
00:11:26.373 --> 00:11:28.813
如果n等于2

306
00:11:28.820 --> 00:11:31.512
δ 的三个元素一一对应

307
00:11:31.512 --> 00:11:33.349
这个

308
00:11:33.349 --> 00:11:35.075
第二个 以及这第三个

309
00:11:35.075 --> 00:11:36.401
式子 这就是为什么

310
00:11:36.410 --> 00:11:38.299
当您更新 θ 值时 根据

311
00:11:38.299 --> 00:11:40.979
θ - αδ 这个式子

312
00:11:41.010 --> 00:11:42.760
我们最终能得到

313
00:11:42.830 --> 00:11:44.948
完全符合最上方更新规则的

314
00:11:44.960 --> 00:11:47.825
同步更新

315
00:11:47.840 --> 00:11:48.960
我知道

316
00:11:48.960 --> 00:11:50.466
幻灯片上的内容很多

317
00:11:50.500 --> 00:11:52.608
但是再次重申

318
00:11:52.650 --> 00:11:54.489
请随时暂停视频

319
00:11:54.510 --> 00:11:56.592
我也鼓励你

320
00:11:56.592 --> 00:11:58.247
一步步对比这两者的差异

321
00:11:58.247 --> 00:11:59.451
如果你不清楚刚才的内容

322
00:11:59.451 --> 00:12:01.719
我希望你能一步一步读幻灯片的内容

323
00:12:01.719 --> 00:12:02.940
以确保你理解

324
00:12:02.940 --> 00:12:04.578
为什么这个式子

325
00:12:04.580 --> 00:12:07.048
用 δ 的这个定理

326
00:12:07.060 --> 00:12:09.612
定义的 好吗 ?

327
00:12:09.612 --> 00:12:10.943
以及它为什么

328
00:12:10.943 --> 00:12:13.714
和最上面的更新方式是等价的

329
00:12:13.714 --> 00:12:15.033
为什么是这样子的

330
00:12:15.033 --> 00:12:18.395
就是这里的式子

331
00:12:18.400 --> 00:12:20.628
这就是向量 x

332
00:12:20.628 --> 00:12:22.109
而我们只是用了

333
00:12:22.109 --> 00:12:23.342
你知道

334
00:12:23.342 --> 00:12:25.516
这三个计算式并且压缩

335
00:12:25.516 --> 00:12:27.106
成一个步骤

336
00:12:27.106 --> 00:12:29.778
用这个向量 δ

337
00:12:29.778 --> 00:12:31.292
这就是为什么我们能够

338
00:12:31.292 --> 00:12:33.465
向量化地实现

339
00:12:33.490 --> 00:12:36.942
线性回归

340
00:12:36.942 --> 00:12:38.639
所以 我希望

341
00:12:38.660 --> 00:12:40.660
步骤是有逻辑的

342
00:12:40.660 --> 00:12:41.791
请务必看视频 并且保证

343
00:12:41.791 --> 00:12:44.013
你确实能理解它

344
00:12:44.013 --> 00:12:46.058
如果你实在不能理解

345
00:12:46.058 --> 00:12:48.029
它们数学上等价的原因

346
00:12:48.029 --> 00:12:49.435
你就直接实现这个算法

347
00:12:49.435 --> 00:12:50.944
也是能得到正确答案的

348
00:12:50.944 --> 00:12:52.224
所以即使你没有

349
00:12:52.224 --> 00:12:56.403
完全理解为何是等价的 如果只是实现这种算法

350
00:12:56.410 --> 00:12:58.992
你仍然能实现线性回归算法

351
00:12:58.992 --> 00:13:00.663
所以如果你能

352
00:13:00.663 --> 00:13:02.216
弄清楚为什么这两个步骤是等价的

353
00:13:02.216 --> 00:13:04.122
那我希望你可以对

354
00:13:04.122 --> 00:13:06.239
向量化有一个更好的理解

355
00:13:06.239 --> 00:13:10.121
以及 最后

356
00:13:10.121 --> 00:13:12.355
如果你在实现线性回归的时候

357
00:13:12.370 --> 00:13:14.872
使用一个或两个以上的特征量

358
00:13:14.872 --> 00:13:16.548
有时我们使用

359
00:13:16.550 --> 00:13:18.078
几十或几百个特征量

360
00:13:18.078 --> 00:13:19.968
来计算线性归回

361
00:13:19.980 --> 00:13:21.853
当你使用向量化地实现

362
00:13:21.853 --> 00:13:23.735
线性回归

363
00:13:23.735 --> 00:13:25.605
通常运行速度就会比你以前用

364
00:13:25.605 --> 00:13:26.892
你的 for 循环快的多

365
00:13:26.892 --> 00:13:28.163
也就是自己

366
00:13:28.163 --> 00:13:31.485
写代码更新 θ0 θ1 θ2

367
00:13:31.500 --> 00:13:33.769
因此使用向量化实现方式

368
00:13:33.769 --> 00:13:34.688
你应该是能够得到

369
00:13:34.688 --> 00:13:37.762
一个高效得多的线性回归算法

370
00:13:37.790 --> 00:13:39.347
而当你向量化

371
00:13:39.347 --> 00:13:40.430
我们将在之后的课程里面学到的算法

372
00:13:40.430 --> 00:13:41.554
这会是一个很好的技巧

373
00:13:41.554 --> 00:13:43.367
无论是对于 Octave 或者

374
00:13:43.367 --> 00:13:44.767
一些其他的语言 如C++

375
00:13:44.767 --> 00:13:48.474
Java 来让你的代码运行得更高效
【教育无边界字幕组】翻译：Jaminalia  校对：所罗门捷列夫 审核：Naplessss